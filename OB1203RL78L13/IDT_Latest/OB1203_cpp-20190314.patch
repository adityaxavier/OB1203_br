--- C:/Users/onkar.raut/Documents/2019H1/Firmware/IDT/OB1203RL78L13/IDT_Latest/OB1203.cpp	Thu Mar 14 11:50:56 2019
+++ C:/Users/onkar.raut/Documents/2019H1/Firmware/IDT/OB1203RL78L13/OB1203/OB1203.cpp	Thu Mar 14 12:07:21 2019
@@ -0,0 +1,4 @@
+#if defined(DEBUG)
+#include <stdio.h>
+#endif
+#include <stddef.h>
@@ -2 +5,0 @@
-#include "mbed.h"
@@ -4 +7,3 @@
-extern Serial pc;
+/* Declare and Initialize the static variables */
+OB1203 * OB1203::current = NULL;
+volatile bool OB1203::busy = false;
@@ -6,2 +11 @@
-//  //
-OB1203::OB1203(I2C *i2c_obj) 
+void OB1203::callback(void)
@@ -9 +13 @@
-    i2c = i2c_obj;
+  busy = false;
@@ -11,0 +16,4 @@
+void OB1203_callback_tx_complete(void)
+{
+  OB1203::callback();
+}
@@ -13 +21 @@
-void OB1203::reset()
+void OB1203_callback_rx_complete(void)
@@ -15,3 +23 @@
-    /*POR reset*/
-    writeRegister(OB1203_ADDR,REG_MAIN_CTRL_0,SW_RESET);
-    wait_ms(POR_TIME_MS);
+  OB1203::callback();
@@ -19,0 +26,9 @@
+void OB1203_callback_error(MD_STATUS status)
+{
+  if(NULL != OB1203::current)
+  {
+    OB1203::current->i2c_error = status;
+    R_IICA0_StopCondition();
+  }
+  OB1203::callback();
+}
@@ -21,6 +36,8 @@
-void OB1203::writeRegister(int addr, char reg, char val) {
- /*writes 1 byte to a single register*/
-    char writeData[2];
-    writeData[0] = reg;
-    writeData[1] = val;
-    i2c->write(addr,writeData, 2);
+OB1203::OB1203(uint8_t addr)
+{
+#if defined(__CA78K0R__) || defined(__CCRL__) || defined(__ICCRL78__) 
+  busy = false;
+  ready = false;
+  i2c_addr = addr;
+  i2c_error = MD_OK;
+#endif //defined(__CA78K0R__) || defined(__CCRL__) || defined(__ICCRL78__) 
@@ -30,7 +47,60 @@
-void OB1203::writeBlock(int addr, char startReg, char *data, char numBytes) {
-/*writes data from an array beginning at the startReg*/
-//    pc.printf("entering writeBlock with data %02x %02x\r\n",data[0],data[1]);
-    char writeData[numBytes+1];
-    writeData[0]=startReg;
-    for(int n=1;n<numBytes+1;n++) {
-        writeData[n]=data[n-1];
+void OB1203::reset()
+{ 
+  current = this;
+#if defined(__CA78K0R__) || defined(__CCRL__) || defined(__ICCRL78__)
+  /* Test if Slave Responds */
+  {
+    do
+    {
+      i2c_error = R_IICA0_Master_Send(i2c_addr, NULL, 0, 1);
+      if(i2c_error==MD_OK)
+      {
+        busy = true;
+      }
+      
+      while(true == busy);
+      
+    }while((i2c_error==MD_ERROR1) || (i2c_error==MD_ERROR2));
+    
+    /* If I2C is IDLE; Power-On Reset the Device over I2C */
+    if(MD_OK==i2c_error)
+    {
+      writeRegister(OB1203_ADDR,REG_MAIN_CTRL_0,SW_RESET);
+      
+      ready = false;
+#if defined(USE_BRUTE_DELAY)      
+      /* 10ms delay */
+      for(volatile uint32_t wait = 0; wait < 12000; wait++)
+      {
+        __no_operation();
+      }
+#endif
+      /* Wait for POR to complete. Check if device is back over the I2C bus. */
+      {
+        do
+        {
+          i2c_error = R_IICA0_Master_Send(i2c_addr, NULL, 0, 1);
+          if(i2c_error==MD_OK)
+          {
+            busy = true;
+          }
+          
+          while(true == busy);
+          
+        }while((i2c_error==MD_ERROR1) || 
+               (i2c_error==MD_ERROR2) || 
+                 (i2c_error==MD_NACK) );
+      }
+      
+      /* Read the status register */
+      if(MD_OK==i2c_error)
+      {
+        uint16_t status_reg_vals = get_status();
+        
+        /* Part is operational after a typical delay of 10 ms. 
+        However, the power on reset bit in STATUS_0 is NOT set. */
+        if((status_reg_vals & 0x8000) == 0)
+        {
+          ready = true;
+        }
+      }
@@ -38 +108,2 @@
-    i2c->write(addr,writeData,numBytes+1);
+  }
+#endif //defined(__CA78K0R__) || defined(__CCRL__) || defined(__ICCRL78__) 
@@ -41,0 +113,75 @@
+void OB1203::writeRegister(int addr, char reg, char val) 
+{
+  current = this;
+  uint8_t writeRegister_writeData[2];
+  /*writes 1 byte to a single register*/
+#if defined(__CA78K0R__) || defined(__CCRL__) || defined(__ICCRL78__) 
+  i2c_addr = addr & 0xFFU;
+  
+  writeRegister_writeData[0] = reg;
+  writeRegister_writeData[1] = val;
+  
+  /* Wait for previous transmission to complete */
+  while(busy == true);
+  
+  /* Send out the data */
+  do
+  {
+    i2c_error = R_IICA0_Master_Send(i2c_addr, &writeRegister_writeData[0], 2, 1);
+    if(i2c_error==MD_OK)
+    {
+      busy = true;
+    }
+    
+    while(true == busy);
+  }while((i2c_error==MD_ERROR1) || (i2c_error==MD_ERROR2));
+#endif //defined(__CA78K0R__) || defined(__CCRL__) || defined(__ICCRL78__) 
+}
+
+
+void OB1203::writeBlock(int addr, char startReg, char *data, char numBytes) 
+{
+  current = this;
+  /*writes data from an array beginning at the startReg*/
+#if defined(DEBUG)
+  printf("entering writeBlock with data %02x %02x\r\n",data[0],data[1]);
+#endif
+  
+#if defined(__CA78K0R__) || defined(__CCRL__) || defined(__ICCRL78__) 
+  uint8_t * writeRegister_writeData = new uint8_t[numBytes + 1];
+  
+  if(NULL != writeRegister_writeData)
+  {
+    writeRegister_writeData[0] = startReg;
+    
+    for(uint16_t itr = 0; itr < numBytes; itr++)
+    {
+      writeRegister_writeData[itr + 1] = data[itr];
+    }
+    
+    
+    /* Wait for previous transmission to complete */
+    while(busy == true);
+    
+    /* Send out the data */
+    do
+    {
+      i2c_error = R_IICA0_Master_Send(i2c_addr, 
+                                      &writeRegister_writeData[0], 
+                                      ((uint8_t)numBytes+1), 
+                                      1);
+      if(i2c_error==MD_OK)
+      {
+        busy = true;
+      }
+      
+      while(true == busy);
+    }while((i2c_error==MD_ERROR1) || (i2c_error==MD_ERROR2));
+    
+    delete(writeRegister_writeData);
+  }
+  delete(writeRegister_writeData);
+#endif //defined(__CA78K0R__) || defined(__CCRL__) || defined(__ICCRL78__) 
+}
+
+
@@ -44,10 +190,31 @@ void OB1203::readBlock(int addr, char startReg, ch
-    char writeData[1];
-    writeData[0] = startReg;
-    i2c->write(addr,writeData,1,true);
-    i2c->read(addr,data,numBytes);
-//    wait_us(800);
-//    for(int n=0;n<numBytes;n++)
-//    {
-//        i2c->read(addr,data+n,1,1);
-//        wait_us(20);
-//    }
+  current = this;
+  i2c_addr = addr & 0xFFU;
+#if defined(__CA78K0R__) || defined(__CCRL__) || defined(__ICCRL78__) 
+  uint8_t readBlock_writeData[1];
+  readBlock_writeData[0] = startReg;
+   
+  /* Wait for previous transmission to complete */
+  while(busy == true);
+  
+  /* Send out the Register to start from */
+  do
+  {
+    i2c_error = R_IICA0_Master_Send(i2c_addr, &readBlock_writeData[0], 1, 1);
+    if(i2c_error==MD_OK)
+    {
+      busy = true;
+    }
+    
+    while(true == busy);
+  }while((i2c_error==MD_ERROR1) || (i2c_error==MD_ERROR2));
+  
+  /* Read the data */
+  do
+  {
+    i2c_error = R_IICA0_Master_Receive(i2c_addr, (uint8_t*)&data[0], (uint16_t)numBytes, 1);
+    if(i2c_error==MD_OK)
+    {
+      busy = true;
+    }
+  }while((i2c_error==MD_ERROR1) || (i2c_error==MD_ERROR2));
+#endif //defined(__CA78K0R__) || defined(__CCRL__) || defined(__ICCRL78__) 
@@ -55,0 +223 @@ void OB1203::readBlock(int addr, char startReg, ch
+
@@ -58,6 +226,33 @@ uint16_t OB1203::get_status()
-    char writeData[1]; //declare array of size 1
-    writeData[0] = REG_STATUS_0; 
-    char data[2]; //declare array of size 1
-    i2c->write(OB1203_ADDR,writeData,1,true);
-    i2c->read(OB1203_ADDR,data,2);
-    return (data[0]<<8 | data[1]);
+  uint8_t get_status_writeData[1]; 
+  uint8_t get_status_readData[2];
+  current = this; 
+#if defined(__CA78K0R__) || defined(__CCRL__) || defined(__ICCRL78__) 
+
+  get_status_writeData[0] = REG_STATUS_0;
+  
+  /* Send out the data */
+  do
+  {
+    i2c_error = R_IICA0_Master_Send(i2c_addr, 
+                                    &get_status_writeData[0], 
+                                    sizeof(get_status_writeData), 
+                                    1);
+    busy = true;
+  }while((i2c_error==MD_ERROR1) || (i2c_error==MD_ERROR2));
+  
+  while(true==busy);
+  
+  /* Read the status bytes */
+  do
+  {
+    i2c_error = R_IICA0_Master_Receive(i2c_addr, 
+                                       get_status_readData, 
+                                       sizeof(get_status_readData),
+                                       1);
+    busy = true;
+  }while((i2c_error==MD_ERROR1) || (i2c_error==MD_ERROR2));
+  
+  while(true==busy);
+    
+#endif //defined(__CA78K0R__) || defined(__CCRL__) || defined(__ICCRL78__) 
+  return (get_status_readData[0]<<8 | get_status_readData[1]);
@@ -105 +300,3 @@ void OB1203::setOscTrim()
-//    pc.printf("writing %02x to REG %02x\r\n",osc_trim,REG_OSC_TRIM);
+#if defined(DEBUG)
+    printf("writing %02x to REG %02x\r\n",osc_trim,REG_OSC_TRIM);
+#endif
@@ -114 +311,3 @@ void OB1203::setMainConfig()
-//    pc.printf("main config 1 to write %02x\r\n",writeData[1]);
+#if defined(DEBUG)
+    printf("main config 1 to write %02x\r\n",writeData[1]);
+#endif
@@ -321,0 +521 @@ void OB1203::init_hr()
+#if defined(DEBUG)    
@@ -323,2 +523,3 @@ void OB1203::init_hr()
-    //readBlock(OB1203_ADDR,REG_PS_INT_CFG_1,readData,1);
-//    pc.printf("int config 1 = %02X\r\n",readData[0]);
+    readBlock(OB1203_ADDR,REG_PS_INT_CFG_1,readData,1);
+    printf("int config 1 = %02X\r\n",readData[0]);
+#endif
@@ -344 +545,3 @@ void OB1203::init_spo2()
-//    pc.printf("int config 1 = %02X\r\n",readData[0]);
+#if defined(DEBUG)    
+    printf("int config 1 = %02X\r\n",readData[0]);
+#endif
@@ -364,2 +567,9 @@ uint32_t OB1203::twoandhalfBytes2uint32(char *data
-    //coverts a string of 3 bytes with LSB first into unsigned long MSB last
-    return (uint32_t)( ((data[start_byte+2] & 0x0F)<<16) | (uint32_t(data[start_byte+1])<<8) | uint32_t(data[start_byte]) ) ;
+  /* coverts a string of 3 bytes with LSB first into unsigned long MSB last */
+  uint32_t out = 0;
+  out |= (data[start_byte+2] & 0x0F);
+  out <<= 8;
+  out |= (data[start_byte+1] & 0x0F);
+  out <<= 8;
+  out |= (data[start_byte+0] & 0x0F);
+  
+  return out;
@@ -372,2 +582,2 @@ char OB1203::get_ls_data(uint32_t *data)
-    #ifdef DEBUG
-        pc.printf("%02x %02x  %02x %02x  %02x %02x %02x  %02x %02x %02x  %02x %02x %02x  %02x %02x  %02x %02x %02x %02x %02x $02x\r\n",
+    #if defined(DEBUG)
+        printf("%02x %02x  %02x %02x  %02x %02x %02x  %02x %02x %02x  %02x %02x %02x  %02x %02x  %02x %02x %02x %02x %02x %02x\r\n",
@@ -378,2 +588,2 @@ char OB1203::get_ls_data(uint32_t *data)
-        byte_data[16],byte_data[17],byte_data[18]),
-        byte_data[19],byte_data[20];
+        byte_data[16],byte_data[17],byte_data[18],
+        byte_data[19],byte_data[20]);
@@ -397,2 +607,2 @@ char OB1203::get_ps_data(uint32_t *data)
-    #ifdef DEBUG
-        pc.printf( "%02x %02x %02x %02x\r\n", byte_data[0], byte_data[1], byte_data[2], byte_data[3] );
+    #if defined(DEBUG)
+        printf( "%02x %02x %02x %02x\r\n", byte_data[0], byte_data[1], byte_data[2], byte_data[3] );
@@ -409,2 +619,2 @@ char OB1203::get_ps_ls_data(uint32_t *data)
-    #ifdef DEBUG
-        pc.printf("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x $02x\r\n",
+    #if defined(DEBUG)
+        printf("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\r\n",
@@ -414,2 +624,2 @@ char OB1203::get_ps_ls_data(uint32_t *data)
-        byte_data[15],byte_data[16],byte_data[17],byte_data[18] ),
-        byte_data[19],byte_data[20];
+        byte_data[15],byte_data[16],byte_data[17],byte_data[18],
+        byte_data[19],byte_data[20]);
@@ -436,0 +647,9 @@ void OB1203::getFifoInfo(char *fifo_info)
+uint8_t OB1203::getNumFifoSamplesAvailable()
+{
+    uint8_t numSamples = writePointer;
+    if (writePointer<readPointer)
+    {
+        numSamples += 31-readPointer;
+    }
+    return numSamples;
+}
